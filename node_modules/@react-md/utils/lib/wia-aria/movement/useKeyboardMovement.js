"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var loop_1 = __importDefault(require("../../loop"));
var useKeyboardSearch_1 = __importDefault(require("../../search/useKeyboardSearch"));
var utils_1 = require("../../search/utils");
var utils_2 = require("./utils");
/**
 * This is a low-level hook for providing custom keyboard movement based on key
 * configurations.  This normally shouldn't really be used externally since
 * you'll most likely want to use the "presets" of `useFocusMovement` and
 * `useActiveDescendantMovement` that implement the main movement types already
 * for you.
 *
 * The way this works is that it will general a list of mutable item refs that
 * should be applied to each DOM node for the corresponding `item` within the
 * `items` list. This list will change and regenerate itself each time the
 * `items` array changes so it'll always be in-sync with the DOM nodes. This
 * means that if you have some items that **should not be rendered**, they
 * should not be included within the items list. The main reason these item refs
 * are required is so that the `aria-acativedescendant` movement can scroll the
 * new "focused" element into view if needed while the "true" focus movement can
 * trigger a `ref.current.focus()` on the new item as needed.
 *
 * Finally, this will create a keydown event handler that will merge in the
 * optionally provided `onKeyDown` prop and check if the pressed key should
 * trigger a custom keyboard movement event.  If it does, an `onChange` event
 * will be fired with the matching data and allows for custom movement with
 * `target.focus()` or updating the `aria-activedescendant` attribute as needed.
 *
 * @typeparam D The type of each data item within the items list.
 * @typeparam CE The HTMLElement type of the container element that handles the
 * custom keyboard movement.
 * @typeparam IE The HTMLElement type of each item within the container element
 * that can be focusable.
 */
function useKeyboardMovement(_a) {
    var onKeyDown = _a.onKeyDown, incrementKeys = _a.incrementKeys, decrementKeys = _a.decrementKeys, jumpToFirstKeys = _a.jumpToFirstKeys, jumpToLastKeys = _a.jumpToLastKeys, _b = _a.stopPropagation, stopPropagation = _b === void 0 ? true : _b, onChange = _a.onChange, items = _a.items, resetTime = _a.resetTime, findMatchIndex = _a.findMatchIndex, focusedIndex = _a.focusedIndex, _c = _a.loopable, loopable = _c === void 0 ? true : _c, _d = _a.searchable, searchable = _d === void 0 ? true : _d, _e = _a.valueKey, valueKey = _e === void 0 ? utils_1.DEFAULT_VALUE_KEY : _e, _f = _a.getItemValue, getItemValue = _f === void 0 ? utils_1.DEFAULT_GET_ITEM_VALUE : _f;
    var keys = react_1.useMemo(function () { return __spreadArrays(utils_2.transformKeys(incrementKeys, "increment"), utils_2.transformKeys(decrementKeys, "decrement"), utils_2.transformKeys(jumpToFirstKeys, "first"), utils_2.transformKeys(jumpToLastKeys, "last")); }, [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]);
    var itemRefs = react_1.useMemo(function () { return Array.from(items, function () { return ({ current: null }); }); }, [items]);
    var handleSearch = useKeyboardSearch_1.default({
        items: items,
        valueKey: valueKey,
        getItemValue: getItemValue,
        onChange: function (data) {
            onChange(data, itemRefs);
        },
        searchIndex: focusedIndex,
        resetTime: resetTime,
        findMatchIndex: findMatchIndex,
    });
    var handleKeyDown = react_1.useCallback(function (event) {
        if (searchable) {
            handleSearch(event);
        }
        if (onKeyDown) {
            onKeyDown(event);
        }
        var target = event.target;
        var keyConfig = utils_2.getKeyboardConfig(event, keys);
        if (!keyConfig || !target) {
            return;
        }
        // implementing custom behavior, so prevent default of scrolling or other
        // things
        event.preventDefault();
        if (stopPropagation) {
            event.stopPropagation();
        }
        var type = keyConfig.type;
        var lastIndex = items.length - 1;
        var index;
        switch (type) {
            case "first":
                index = 0;
                break;
            case "last":
                index = lastIndex;
                break;
            default:
                index = loop_1.default(focusedIndex, lastIndex, type === "increment", !loopable);
        }
        if (index === focusedIndex) {
            return;
        }
        var data = {
            index: index,
            item: items[index],
            items: items,
            query: utils_2.getStringifiedKeyConfig(keyConfig),
            target: event.currentTarget,
        };
        onChange(data, itemRefs);
    }, [
        onKeyDown,
        stopPropagation,
        focusedIndex,
        keys,
        items,
        handleSearch,
        loopable,
        searchable,
        onChange,
        itemRefs,
    ]);
    return [itemRefs, handleKeyDown];
}
exports.default = useKeyboardMovement;
//# sourceMappingURL=useKeyboardMovement.js.map