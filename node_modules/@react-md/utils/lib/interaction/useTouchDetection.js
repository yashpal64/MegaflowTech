"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_TOUCH_TIMEOUT = void 0;
var react_1 = require("react");
var useRefCache_1 = __importDefault(require("../useRefCache"));
exports.DEFAULT_TOUCH_TIMEOUT = 1200;
/**
 * This is a small hook that is used to determine if the app is currently being
 * used by a touch device or not. All this really does is switch between
 * mousemove and touchstart events to determine which mode you are in.  This
 * also tracks the `contextmenu` appearance since long touches can trigger the
 * context menu on mobile devices. When the context menu appears after a touch,
 * the mode will still be considered "touch" instead of swapping to mouse.
 *
 * @param touchTimeout This is the amount of time that can occur between a
 * touchstart and mousemove event but still be considered part of a "touch" user
 * mode. This should probably be kept at the default value, but if the touch
 * mode isn't updating as you would expect, you can try increasing or decreasing
 * this value until it does.
 * @return true if the app is in touch mode.
 * @private
 */
function useTouchDetection(touchTimeout) {
    if (touchTimeout === void 0) { touchTimeout = exports.DEFAULT_TOUCH_TIMEOUT; }
    var _a = react_1.useState(0), lastTouchTime = _a[0], setTouchTime = _a[1];
    var touchRef = useRefCache_1.default(lastTouchTime);
    var contextMenuRef = react_1.useRef(false);
    var updateTouchTime = react_1.useCallback(function () {
        setTouchTime(Date.now());
        contextMenuRef.current = false;
    }, []);
    var resetTouchTime = react_1.useCallback(function () {
        var lastTouchTime = touchRef.current;
        if (contextMenuRef.current || Date.now() - lastTouchTime < touchTimeout) {
            contextMenuRef.current = false;
            return;
        }
        setTouchTime(0);
        // disabled since useRefCache for touchRef
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [touchTimeout]);
    react_1.useEffect(function () {
        window.addEventListener("touchstart", updateTouchTime, true);
        return function () {
            window.removeEventListener("touchstart", updateTouchTime, true);
        };
    }, [updateTouchTime]);
    react_1.useEffect(function () {
        if (lastTouchTime === 0) {
            contextMenuRef.current = false;
            return;
        }
        var updateContextMenu = function () {
            contextMenuRef.current = true;
        };
        window.addEventListener("mousemove", resetTouchTime, true);
        window.addEventListener("contextmenu", updateContextMenu, true);
        return function () {
            window.removeEventListener("mousemove", resetTouchTime, true);
            window.removeEventListener("contextmenu", updateContextMenu, true);
        };
    }, [lastTouchTime, resetTouchTime]);
    return lastTouchTime !== 0;
}
exports.default = useTouchDetection;
//# sourceMappingURL=useTouchDetection.js.map