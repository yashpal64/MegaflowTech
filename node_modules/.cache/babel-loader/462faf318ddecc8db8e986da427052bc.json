{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React from 'react';\nimport { getVideoState, formatVideoSrc, formatVideoCaptions } from './utils';\nimport { VIDEO_STATE, HOVER_PLAYER_STATE, SIZING_MODES, expandToFillContainerStyle, pausedOverlayWrapperSizingStyles, videoSizingStyles } from './constants';\n/**\n * @component HoverVideoPlayer\n *\n * @param {(string|string[]|VideoSource|VideoSource[])}  videoSrc - Source(s) to use for the video player. Accepts 3 different formats:\n *                                                                   - **String**: the URL string to use as the video player's src\n *                                                                   - **Object**: an object with attributes:\n *                                                                     - src: The src URL string to use for a video player source\n *                                                                     - type: The media type of the video source, ie 'video/mp4'\n *                                                                   - **Array**: if you would like to provide multiple sources, you can provide an array of URL strings and/or objects with the shape described above\n * @param {(VideoCaptionsTrack|VideoCaptionsTrack[])} [videoCaptions] - Captions track(s) to use for the video player for accessibility. Accepts 2 formats:\n *                                                                                      - **Object**: an object with attributes:\n *                                                                                        - src: The src URL string for the captions track file\n *                                                                                        - srcLang: The language code for the language that these captions are in (ie, 'en', 'es', 'fr')\n *                                                                                        - label: The title of the captions track\n *                                                                                        - default: Whether this track should be used by default if the user's preferences don't match an available srcLang\n *                                                                                      - **Array**: if you would like to provide multiple caption tracks, you can provide an array of objects with the shape described above\n * @param {boolean} [focused=false] - Offers a prop interface for forcing the video to start/stop without DOM events\n *                                      When set to true, the video will begin playing and any events that would normally stop it will be ignored\n * @param {boolean} [disableDefaultEventHandling] - Whether the video player's default mouse and touch event handling should be disabled in favor of a fully custom solution using the `focused` prop\n * @param {node}    [hoverTargetRef] - Ref to a custom element that should be used as the target for hover events to start/stop the video\n *                                      By default will just use the container div wrapping the player\n * @param {node}    [pausedOverlay] - Contents to render over the video while it's not playing\n * @param {node}    [loadingOverlay] - Contents to render over the video while it's loading\n * @param {number}  [loadingStateTimeout=200] - Duration in ms to wait after attempting to start the video before showing the loading overlay\n * @param {number}  [overlayTransitionDuration=400] - The transition duration in ms for how long it should take for the overlay to fade in/out\n * @param {boolean} [restartOnPaused=false] - Whether the video should reset to the beginning every time it stops playing after the user mouses out of the player\n * @param {boolean} [unloadVideoOnPaused=false] - Whether we should unload the video's sources when it is not playing in order to free up memory and bandwidth\n *                                                  This can be useful in scenarios where you may have a large number of relatively large video files on a single page;\n *                                                  particularly due to a known bug in Google Chrome, if too many videos are loading in the background at the same time,\n *                                                  it starts to gum up the works so that nothing loads properly and performance can degrade significantly.\n * @param {boolean} [muted=true] - Whether the video player should be muted\n * @param {boolean} [loop=true] - Whether the video player should loop when it reaches the end\n * @param {string}  [preload] - Sets how much information the video element should preload before being played. Accepts one of the following values:\n *                              - **\"none\"**: Nothing should be preloaded before the video is played\n *                              - **\"metadata\"**: Only the video's metadata (ie length, dimensions) should be preloaded\n *                              - **\"auto\"**: The whole video file should be preloaded even if it won't be played\n * @param {string}  [className] - Optional className to apply custom styling to the container element\n * @param {object}  [style] - Style object to apply custom inlined styles to the hover player container\n * @param {string}  [pausedOverlayWrapperClassName] - Optional className to apply custom styling to the overlay contents' wrapper\n * @param {object}  [pausedOverlayWrapperStyle] - Style object to apply custom inlined styles to the paused overlay wrapper\n * @param {string}  [loadingOverlayWrapperClassName] - Optional className to apply custom styling to the loading state overlay contents' wrapper\n * @param {object}  [loadingOverlayWrapperStyle] - Style object to apply custom inlined styles to the loading overlay wrapper\n * @param {string}  [videoClassName] - Optional className to apply custom styling to the video element\n * @param {object}  [videoStyle] - Style object to apply custom inlined styles to the video element\n * @param {string}  [sizingMode='video'] - Describes sizing mode to use to determine how the player's contents should be styled. Accepts 4 possible values:\n *                                         - **\"video\"**: Everything should be sized based on the video element's dimensions - the overlays will expand to cover the video\n *                                         - **\"overlay\"**: Everything should be sized based on the paused overlay's dimensions - the video element will expand to fit inside those dimensions\n *                                         - **\"container\"**: Everything should be sized based on the player's outer container div - the overlays and video will all expand to cover the container\n *                                         - **\"manual\"**: Manual mode does not apply any special styling and allows the developer to exercise full control over how everything should be sized - this means you will likely need to provide your own custom styling for both the paused overlay and the video element\n *\n * @license MIT\n */\n\nexport default function HoverVideoPlayer(_ref) {\n  var videoSrc = _ref.videoSrc,\n      _ref$videoCaptions = _ref.videoCaptions,\n      videoCaptions = _ref$videoCaptions === void 0 ? null : _ref$videoCaptions,\n      _ref$focused = _ref.focused,\n      focused = _ref$focused === void 0 ? false : _ref$focused,\n      _ref$disableDefaultEv = _ref.disableDefaultEventHandling,\n      disableDefaultEventHandling = _ref$disableDefaultEv === void 0 ? false : _ref$disableDefaultEv,\n      _ref$hoverTargetRef = _ref.hoverTargetRef,\n      hoverTargetRef = _ref$hoverTargetRef === void 0 ? null : _ref$hoverTargetRef,\n      _ref$pausedOverlay = _ref.pausedOverlay,\n      pausedOverlay = _ref$pausedOverlay === void 0 ? null : _ref$pausedOverlay,\n      _ref$loadingOverlay = _ref.loadingOverlay,\n      loadingOverlay = _ref$loadingOverlay === void 0 ? null : _ref$loadingOverlay,\n      _ref$loadingStateTime = _ref.loadingStateTimeout,\n      loadingStateTimeout = _ref$loadingStateTime === void 0 ? 200 : _ref$loadingStateTime,\n      _ref$overlayTransitio = _ref.overlayTransitionDuration,\n      overlayTransitionDuration = _ref$overlayTransitio === void 0 ? 400 : _ref$overlayTransitio,\n      _ref$restartOnPaused = _ref.restartOnPaused,\n      restartOnPaused = _ref$restartOnPaused === void 0 ? false : _ref$restartOnPaused,\n      _ref$unloadVideoOnPau = _ref.unloadVideoOnPaused,\n      unloadVideoOnPaused = _ref$unloadVideoOnPau === void 0 ? false : _ref$unloadVideoOnPau,\n      _ref$muted = _ref.muted,\n      muted = _ref$muted === void 0 ? true : _ref$muted,\n      _ref$loop = _ref.loop,\n      loop = _ref$loop === void 0 ? true : _ref$loop,\n      _ref$preload = _ref.preload,\n      preload = _ref$preload === void 0 ? null : _ref$preload,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      _ref$style = _ref.style,\n      style = _ref$style === void 0 ? null : _ref$style,\n      _ref$pausedOverlayWra = _ref.pausedOverlayWrapperClassName,\n      pausedOverlayWrapperClassName = _ref$pausedOverlayWra === void 0 ? '' : _ref$pausedOverlayWra,\n      _ref$pausedOverlayWra2 = _ref.pausedOverlayWrapperStyle,\n      pausedOverlayWrapperStyle = _ref$pausedOverlayWra2 === void 0 ? null : _ref$pausedOverlayWra2,\n      _ref$loadingOverlayWr = _ref.loadingOverlayWrapperClassName,\n      loadingOverlayWrapperClassName = _ref$loadingOverlayWr === void 0 ? '' : _ref$loadingOverlayWr,\n      _ref$loadingOverlayWr2 = _ref.loadingOverlayWrapperStyle,\n      loadingOverlayWrapperStyle = _ref$loadingOverlayWr2 === void 0 ? null : _ref$loadingOverlayWr2,\n      _ref$videoClassName = _ref.videoClassName,\n      videoClassName = _ref$videoClassName === void 0 ? '' : _ref$videoClassName,\n      _ref$videoStyle = _ref.videoStyle,\n      videoStyle = _ref$videoStyle === void 0 ? null : _ref$videoStyle,\n      _ref$sizingMode = _ref.sizingMode,\n      sizingMode = _ref$sizingMode === void 0 ? SIZING_MODES.video : _ref$sizingMode; // Keep track of state to determine how the paused and loading overlays should be displayed\n\n  var _React$useState = React.useState(HOVER_PLAYER_STATE.paused),\n      overlayState = _React$useState[0],\n      setOverlayState = _React$useState[1]; // Keep track of whether the video is unloaded, meaning its sources should be removed from\n  // the DOM and unloaded for optimization purposes\n  // This is only relevant if `unloadVideoOnPaused` is set to true\n\n\n  var _React$useState2 = React.useState(unloadVideoOnPaused),\n      isVideoUnloaded = _React$useState2[0],\n      setIsVideoUnloaded = _React$useState2[1]; // Keep refs to previous state values for comparison in effect hooks\n\n\n  var previousIsVideoUnloadedRef = React.useRef(isVideoUnloaded);\n  var previousFocusedRef = React.useRef(false); // Keep a ref for all state variables related to the video's state\n  // which need to be managed asynchronously as it attempts to play/pause\n\n  var mutableVideoState = React.useRef(null);\n\n  if (mutableVideoState.current === null) {\n    // Set initial values for our video state\n    mutableVideoState.current = {\n      isPlayAttemptInProgress: false,\n      isPlayAttemptCancelled: false,\n      isPlayerUnmounted: false,\n      // Keep refs for timeouts so we can keep track of and cancel them\n      pauseTimeout: null,\n      loadingStateTimeout: null,\n      // Keep track of the video time that we should start from when the video is played again\n      // This is particularly useful so we can restore our previous place in the video even if\n      // we are unloading it every time it gets paused\n      videoTimeToRestore: 0\n    };\n  } // Element refs\n\n\n  var containerRef = React.useRef(null);\n  var videoRef = React.useRef(null);\n  /**\n   * @function  pauseVideo\n   *\n   * Pauses the video and unloads it if necessary\n   */\n\n  var pauseVideo = React.useCallback(function () {\n    var videoElement = videoRef.current;\n    videoElement.pause();\n\n    if (restartOnPaused) {\n      // If we should restart the video, reset its time to the beginning next time we play\n      videoElement.currentTime = 0;\n    } // Hang onto the time that the video is currently at so we can restore it when we try to play\n    // again even if the video was unloaded\n\n\n    mutableVideoState.current.videoTimeToRestore = videoElement.currentTime;\n\n    if (unloadVideoOnPaused) {\n      // If necessary, unload the video now that it's paused\n      setIsVideoUnloaded(true);\n    }\n  }, [restartOnPaused, unloadVideoOnPaused]);\n  /**\n   * @function playVideo\n   *\n   * Attempts to play the video if it is not already playing\n   */\n\n  var playVideo = React.useCallback(function () {\n    // Clear any timeouts that may have been in progress\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    var videoElement = videoRef.current; // Make sure our play attempt is no longer cancelled since the user is hovering on it again\n\n    mutableVideoState.current.isPlayAttemptCancelled = false; // If the video is already playing, just make sure we keep the overlays hidden\n\n    if (getVideoState(videoElement) === VIDEO_STATE.playing) {\n      setOverlayState(HOVER_PLAYER_STATE.playing);\n      return;\n    }\n\n    if (loadingOverlay) {\n      // If we have a loading overlay, start a timeout to fade it in if it takes too long\n      // for playback to start\n      mutableVideoState.current.loadingStateTimeout = setTimeout(function () {\n        // If the video is still loading when this timeout completes, transition the\n        // player to show a loading state\n        setOverlayState(HOVER_PLAYER_STATE.loading);\n      }, loadingStateTimeout);\n    } // If a play attempt is already in progress, don't start a new one\n\n\n    if (mutableVideoState.current.isPlayAttemptInProgress) return; // We are now attempting to play the video\n\n    mutableVideoState.current.isPlayAttemptInProgress = true; // Ensure we're at the correct video time to start playing from\n\n    videoElement.currentTime = mutableVideoState.current.videoTimeToRestore; // Start playing the video and hang onto the play promise it returns\n\n    var playPromise = videoElement.play();\n\n    if (!playPromise || !playPromise.then) {\n      // If videoElement.play() didn't return a promise, we'll manually create one\n      // ourselves which mimics the same behavior\n      playPromise = new Promise(function (resolve, reject) {\n        // Declaring onVideoPlaybackFailed up here so we can refer to it and remove its event listener\n        // if the video successfully starts playing\n        var _onVideoPlaybackFailed; // Set up event listener to resolve the promise when the video player starts playing\n\n\n        var onVideoPlaybackStarted = function onVideoPlaybackStarted() {\n          // Remove the event listeners we added as cleanup now that the play attempt has succeeded\n          videoElement.removeEventListener('playing', onVideoPlaybackStarted);\n          videoElement.removeEventListener('error', _onVideoPlaybackFailed); // Resolve because we successfully started playing!\n\n          resolve();\n        };\n\n        videoElement.addEventListener('playing', onVideoPlaybackStarted); // Set up event listener to reject the promise when the video player encounters an error\n\n        _onVideoPlaybackFailed = function onVideoPlaybackFailed(event) {\n          // Remove the event listeners we added as cleanup now that the play attempt has failed\n          videoElement.removeEventListener('error', _onVideoPlaybackFailed);\n          videoElement.removeEventListener('playing', onVideoPlaybackStarted); // Reject with the error that was thrown\n\n          reject(event.error);\n        };\n\n        videoElement.addEventListener('error', _onVideoPlaybackFailed);\n      });\n    }\n\n    playPromise.then(function () {\n      // If the player was unmounted before the play promise could resolve, don't do anything\n      if (mutableVideoState.current.isPlayerUnmounted) return;\n\n      if (mutableVideoState.current.isPlayAttemptCancelled) {\n        // If the play attempt was cancelled, immediately pause the video\n        pauseVideo();\n      } else {\n        // If the play attempt wasn't cancelled, hide the overlays to reveal the video now that it's playing\n        setOverlayState(HOVER_PLAYER_STATE.playing);\n      }\n    })[\"catch\"](function (error) {\n      console.error(\"HoverVideoPlayer playback failed for src \" + videoElement.currentSrc + \":\", error);\n\n      if (!mutableVideoState.current.isPlayerUnmounted) {\n        // If the player is still mounted, revert to a paused state\n        pauseVideo();\n      }\n    })[\"finally\"](function () {\n      // The play attempt is now complete\n      mutableVideoState.current.isPlayAttemptInProgress = false;\n      mutableVideoState.current.isPlayAttemptCancelled = false;\n      clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    });\n  }, [loadingOverlay, loadingStateTimeout, pauseVideo]);\n  /**\n   * @function  onHoverStart\n   *\n   * Starts the video when the user mouses hovers on the player\n   */\n\n  var onHoverStart = React.useCallback(function () {\n    if (isVideoUnloaded) {\n      // If the video is currently unloaded, we need to make sure we update our state\n      // to restore the video's sources before we attempt to play it\n      setIsVideoUnloaded(false);\n    } else {\n      playVideo();\n    }\n  }, [isVideoUnloaded, playVideo]);\n  /**\n   * @function  onHoverEnd\n   *\n   * Stops the video and fades the paused overlay in when the user stops hovering on the player\n   */\n\n  var onHoverEnd = React.useCallback(function () {\n    // Clear any timeouts that may have been in progress\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    var videoElement = videoRef.current; // If the focused override prop is active, ignore any other events attempting to stop the video\n    // Also don't do anything if the video is already paused\n\n    if (focused || getVideoState(videoElement) === VIDEO_STATE.paused) return; // Start fading the paused overlay back in\n\n    setOverlayState(HOVER_PLAYER_STATE.paused);\n\n    if (mutableVideoState.current.isPlayAttemptInProgress) {\n      // If we have a play attempt in progress, mark that the play attempt should be cancelled\n      // so that as soon as the promise resolves, the video should be paused\n      mutableVideoState.current.isPlayAttemptCancelled = true;\n    } else if (pausedOverlay) {\n      // If we have a paused overlay, set a timeout with a duration of the overlay's fade\n      // transition since we want to keep the video playing until the overlay has fully\n      // faded in and hidden it.\n      mutableVideoState.current.pauseTimeout = setTimeout(function () {\n        return pauseVideo();\n      }, overlayTransitionDuration);\n    } else {\n      // If a play attempt isn't in progress and there is no paused overlay, just pause\n      pauseVideo();\n    }\n  }, [focused, overlayTransitionDuration, pauseVideo, pausedOverlay]);\n  /* ~~~~ EFFECTS ~~~~ */\n\n  React.useEffect(function () {\n    // If the focused prop hasn't changed, don't do anything\n    if (previousFocusedRef.current === focused) return; // Use effect to start/stop the video when focused override prop changes\n\n    if (focused) {\n      onHoverStart();\n    } else {\n      onHoverEnd();\n    }\n\n    previousFocusedRef.current = focused;\n  }, [focused, onHoverEnd, onHoverStart]);\n  React.useEffect(function () {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling) return undefined;\n    var hoverTargetElement = // If a ref to a custom hover target was provided, we'll use that as our target element\n    hoverTargetRef ? hoverTargetRef.current : // If no custom target was provided, default to the player's container div\n    containerRef.current; // Add all relevant event listeners to the target element to make\n    // it start and stop correctly\n\n    hoverTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverTargetElement.addEventListener('mouseleave', onHoverEnd);\n    hoverTargetElement.addEventListener('focus', onHoverStart);\n    hoverTargetElement.addEventListener('blur', onHoverEnd);\n    hoverTargetElement.addEventListener('touchstart', onHoverStart); // Event listener pauses the video when the user touches somewhere outside of the player\n\n    function onWindowTouchStart(event) {\n      if (!hoverTargetElement.contains(event.target)) {\n        onHoverEnd();\n      }\n    }\n\n    window.addEventListener('touchstart', onWindowTouchStart); // Remove all event listeners on cleanup\n\n    return function () {\n      hoverTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverTargetElement.removeEventListener('focus', onHoverStart);\n      hoverTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetRef, onHoverEnd, onHoverStart]);\n  React.useEffect(function () {\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    videoRef.current.muted = muted;\n  }, [muted]);\n  React.useEffect(function () {\n    // Don't do anything if the video's unloaded state hasn't changed\n    if (previousIsVideoUnloadedRef.current === isVideoUnloaded) return; // Since the video's sources have changed, perform a manual load to update\n    // or unload the video's current source\n\n    videoRef.current.load();\n\n    if (!isVideoUnloaded) {\n      // If the video was just changed from being unloaded, that means we're trying to play,\n      // so let's kick off a play attempt now that the video's sources are restored\n      playVideo();\n    }\n\n    previousIsVideoUnloadedRef.current = isVideoUnloaded;\n  }, [isVideoUnloaded, onHoverStart, playVideo]);\n  React.useEffect(function () {\n    var videoElement = videoRef.current; // Ensure casting and PiP controls aren't shown on the video\n\n    videoElement.disableRemotePlayback = true;\n    videoElement.disablePictureInPicture = true;\n    return function () {\n      // Clear any outstanding timeouts when the component unmounts to prevent memory leaks\n      clearTimeout(mutableVideoState.current.pauseTimeout);\n      clearTimeout(mutableVideoState.current.loadingStateTimeout); // Mark that the player is unmounted so that we won't try to update the component state\n      // if the play promise resolves afterward\n\n      mutableVideoState.current.isPlayerUnmounted = true;\n    };\n  }, []);\n  /* ~~~~ END EFFECTS ~~~~ */\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    \"data-testid\": \"hover-video-player-container\",\n    ref: containerRef,\n    className: className,\n    style: _extends({\n      position: 'relative'\n    }, style)\n  }, pausedOverlay && /*#__PURE__*/React.createElement(\"div\", {\n    style: _extends({}, pausedOverlayWrapperSizingStyles[sizingMode], {\n      zIndex: 1,\n      opacity: overlayState !== HOVER_PLAYER_STATE.playing ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\"\n    }, pausedOverlayWrapperStyle),\n    className: pausedOverlayWrapperClassName,\n    \"data-testid\": \"paused-overlay-wrapper\"\n  }, pausedOverlay), loadingOverlay && /*#__PURE__*/React.createElement(\"div\", {\n    style: _extends({}, expandToFillContainerStyle, {\n      zIndex: 2,\n      opacity: overlayState === HOVER_PLAYER_STATE.loading ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\"\n    }, loadingOverlayWrapperStyle),\n    className: loadingOverlayWrapperClassName,\n    \"data-testid\": \"loading-overlay-wrapper\"\n  }, loadingOverlay), /*#__PURE__*/React.createElement(\"video\", {\n    loop: loop,\n    playsInline: true,\n    preload: preload,\n    ref: videoRef,\n    style: _extends({}, videoSizingStyles[sizingMode], {\n      objectFit: 'cover'\n    }, videoStyle),\n    className: videoClassName,\n    \"data-testid\": \"video-element\"\n  }, !isVideoUnloaded && // If the video is not unloaded, parse the `videoSrc` prop into an array of objects and render them\n  // as sources for the video\n  formatVideoSrc(videoSrc).map(function (_ref2) {\n    var src = _ref2.src,\n        type = _ref2.type;\n    return /*#__PURE__*/React.createElement(\"source\", {\n      key: src,\n      src: src,\n      type: type\n    });\n  }), formatVideoCaptions(videoCaptions).map(function (_ref3) {\n    var src = _ref3.src,\n        srcLang = _ref3.srcLang,\n        label = _ref3.label,\n        isDefault = _ref3[\"default\"];\n    return /*#__PURE__*/React.createElement(\"track\", {\n      key: src,\n      kind: \"captions\",\n      src: src,\n      srcLang: srcLang,\n      label: label,\n      \"default\": isDefault\n    });\n  })));\n}","map":{"version":3,"sources":["C:/Users/Abhinandan Singhal/Desktop/Nayi-Website/node_modules/react-hover-video-player/es/index.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","React","getVideoState","formatVideoSrc","formatVideoCaptions","VIDEO_STATE","HOVER_PLAYER_STATE","SIZING_MODES","expandToFillContainerStyle","pausedOverlayWrapperSizingStyles","videoSizingStyles","HoverVideoPlayer","_ref","videoSrc","_ref$videoCaptions","videoCaptions","_ref$focused","focused","_ref$disableDefaultEv","disableDefaultEventHandling","_ref$hoverTargetRef","hoverTargetRef","_ref$pausedOverlay","pausedOverlay","_ref$loadingOverlay","loadingOverlay","_ref$loadingStateTime","loadingStateTimeout","_ref$overlayTransitio","overlayTransitionDuration","_ref$restartOnPaused","restartOnPaused","_ref$unloadVideoOnPau","unloadVideoOnPaused","_ref$muted","muted","_ref$loop","loop","_ref$preload","preload","_ref$className","className","_ref$style","style","_ref$pausedOverlayWra","pausedOverlayWrapperClassName","_ref$pausedOverlayWra2","pausedOverlayWrapperStyle","_ref$loadingOverlayWr","loadingOverlayWrapperClassName","_ref$loadingOverlayWr2","loadingOverlayWrapperStyle","_ref$videoClassName","videoClassName","_ref$videoStyle","videoStyle","_ref$sizingMode","sizingMode","video","_React$useState","useState","paused","overlayState","setOverlayState","_React$useState2","isVideoUnloaded","setIsVideoUnloaded","previousIsVideoUnloadedRef","useRef","previousFocusedRef","mutableVideoState","current","isPlayAttemptInProgress","isPlayAttemptCancelled","isPlayerUnmounted","pauseTimeout","videoTimeToRestore","containerRef","videoRef","pauseVideo","useCallback","videoElement","pause","currentTime","playVideo","clearTimeout","playing","setTimeout","loading","playPromise","play","then","Promise","resolve","reject","_onVideoPlaybackFailed","onVideoPlaybackStarted","removeEventListener","addEventListener","onVideoPlaybackFailed","event","error","console","currentSrc","onHoverStart","onHoverEnd","useEffect","undefined","hoverTargetElement","onWindowTouchStart","contains","window","load","disableRemotePlayback","disablePictureInPicture","createElement","ref","position","zIndex","opacity","transition","playsInline","objectFit","map","_ref2","src","type","_ref3","srcLang","label","isDefault","kind"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport { getVideoState, formatVideoSrc, formatVideoCaptions } from './utils';\nimport { VIDEO_STATE, HOVER_PLAYER_STATE, SIZING_MODES, expandToFillContainerStyle, pausedOverlayWrapperSizingStyles, videoSizingStyles } from './constants';\n/**\n * @component HoverVideoPlayer\n *\n * @param {(string|string[]|VideoSource|VideoSource[])}  videoSrc - Source(s) to use for the video player. Accepts 3 different formats:\n *                                                                   - **String**: the URL string to use as the video player's src\n *                                                                   - **Object**: an object with attributes:\n *                                                                     - src: The src URL string to use for a video player source\n *                                                                     - type: The media type of the video source, ie 'video/mp4'\n *                                                                   - **Array**: if you would like to provide multiple sources, you can provide an array of URL strings and/or objects with the shape described above\n * @param {(VideoCaptionsTrack|VideoCaptionsTrack[])} [videoCaptions] - Captions track(s) to use for the video player for accessibility. Accepts 2 formats:\n *                                                                                      - **Object**: an object with attributes:\n *                                                                                        - src: The src URL string for the captions track file\n *                                                                                        - srcLang: The language code for the language that these captions are in (ie, 'en', 'es', 'fr')\n *                                                                                        - label: The title of the captions track\n *                                                                                        - default: Whether this track should be used by default if the user's preferences don't match an available srcLang\n *                                                                                      - **Array**: if you would like to provide multiple caption tracks, you can provide an array of objects with the shape described above\n * @param {boolean} [focused=false] - Offers a prop interface for forcing the video to start/stop without DOM events\n *                                      When set to true, the video will begin playing and any events that would normally stop it will be ignored\n * @param {boolean} [disableDefaultEventHandling] - Whether the video player's default mouse and touch event handling should be disabled in favor of a fully custom solution using the `focused` prop\n * @param {node}    [hoverTargetRef] - Ref to a custom element that should be used as the target for hover events to start/stop the video\n *                                      By default will just use the container div wrapping the player\n * @param {node}    [pausedOverlay] - Contents to render over the video while it's not playing\n * @param {node}    [loadingOverlay] - Contents to render over the video while it's loading\n * @param {number}  [loadingStateTimeout=200] - Duration in ms to wait after attempting to start the video before showing the loading overlay\n * @param {number}  [overlayTransitionDuration=400] - The transition duration in ms for how long it should take for the overlay to fade in/out\n * @param {boolean} [restartOnPaused=false] - Whether the video should reset to the beginning every time it stops playing after the user mouses out of the player\n * @param {boolean} [unloadVideoOnPaused=false] - Whether we should unload the video's sources when it is not playing in order to free up memory and bandwidth\n *                                                  This can be useful in scenarios where you may have a large number of relatively large video files on a single page;\n *                                                  particularly due to a known bug in Google Chrome, if too many videos are loading in the background at the same time,\n *                                                  it starts to gum up the works so that nothing loads properly and performance can degrade significantly.\n * @param {boolean} [muted=true] - Whether the video player should be muted\n * @param {boolean} [loop=true] - Whether the video player should loop when it reaches the end\n * @param {string}  [preload] - Sets how much information the video element should preload before being played. Accepts one of the following values:\n *                              - **\"none\"**: Nothing should be preloaded before the video is played\n *                              - **\"metadata\"**: Only the video's metadata (ie length, dimensions) should be preloaded\n *                              - **\"auto\"**: The whole video file should be preloaded even if it won't be played\n * @param {string}  [className] - Optional className to apply custom styling to the container element\n * @param {object}  [style] - Style object to apply custom inlined styles to the hover player container\n * @param {string}  [pausedOverlayWrapperClassName] - Optional className to apply custom styling to the overlay contents' wrapper\n * @param {object}  [pausedOverlayWrapperStyle] - Style object to apply custom inlined styles to the paused overlay wrapper\n * @param {string}  [loadingOverlayWrapperClassName] - Optional className to apply custom styling to the loading state overlay contents' wrapper\n * @param {object}  [loadingOverlayWrapperStyle] - Style object to apply custom inlined styles to the loading overlay wrapper\n * @param {string}  [videoClassName] - Optional className to apply custom styling to the video element\n * @param {object}  [videoStyle] - Style object to apply custom inlined styles to the video element\n * @param {string}  [sizingMode='video'] - Describes sizing mode to use to determine how the player's contents should be styled. Accepts 4 possible values:\n *                                         - **\"video\"**: Everything should be sized based on the video element's dimensions - the overlays will expand to cover the video\n *                                         - **\"overlay\"**: Everything should be sized based on the paused overlay's dimensions - the video element will expand to fit inside those dimensions\n *                                         - **\"container\"**: Everything should be sized based on the player's outer container div - the overlays and video will all expand to cover the container\n *                                         - **\"manual\"**: Manual mode does not apply any special styling and allows the developer to exercise full control over how everything should be sized - this means you will likely need to provide your own custom styling for both the paused overlay and the video element\n *\n * @license MIT\n */\n\nexport default function HoverVideoPlayer(_ref) {\n  var videoSrc = _ref.videoSrc,\n      _ref$videoCaptions = _ref.videoCaptions,\n      videoCaptions = _ref$videoCaptions === void 0 ? null : _ref$videoCaptions,\n      _ref$focused = _ref.focused,\n      focused = _ref$focused === void 0 ? false : _ref$focused,\n      _ref$disableDefaultEv = _ref.disableDefaultEventHandling,\n      disableDefaultEventHandling = _ref$disableDefaultEv === void 0 ? false : _ref$disableDefaultEv,\n      _ref$hoverTargetRef = _ref.hoverTargetRef,\n      hoverTargetRef = _ref$hoverTargetRef === void 0 ? null : _ref$hoverTargetRef,\n      _ref$pausedOverlay = _ref.pausedOverlay,\n      pausedOverlay = _ref$pausedOverlay === void 0 ? null : _ref$pausedOverlay,\n      _ref$loadingOverlay = _ref.loadingOverlay,\n      loadingOverlay = _ref$loadingOverlay === void 0 ? null : _ref$loadingOverlay,\n      _ref$loadingStateTime = _ref.loadingStateTimeout,\n      loadingStateTimeout = _ref$loadingStateTime === void 0 ? 200 : _ref$loadingStateTime,\n      _ref$overlayTransitio = _ref.overlayTransitionDuration,\n      overlayTransitionDuration = _ref$overlayTransitio === void 0 ? 400 : _ref$overlayTransitio,\n      _ref$restartOnPaused = _ref.restartOnPaused,\n      restartOnPaused = _ref$restartOnPaused === void 0 ? false : _ref$restartOnPaused,\n      _ref$unloadVideoOnPau = _ref.unloadVideoOnPaused,\n      unloadVideoOnPaused = _ref$unloadVideoOnPau === void 0 ? false : _ref$unloadVideoOnPau,\n      _ref$muted = _ref.muted,\n      muted = _ref$muted === void 0 ? true : _ref$muted,\n      _ref$loop = _ref.loop,\n      loop = _ref$loop === void 0 ? true : _ref$loop,\n      _ref$preload = _ref.preload,\n      preload = _ref$preload === void 0 ? null : _ref$preload,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      _ref$style = _ref.style,\n      style = _ref$style === void 0 ? null : _ref$style,\n      _ref$pausedOverlayWra = _ref.pausedOverlayWrapperClassName,\n      pausedOverlayWrapperClassName = _ref$pausedOverlayWra === void 0 ? '' : _ref$pausedOverlayWra,\n      _ref$pausedOverlayWra2 = _ref.pausedOverlayWrapperStyle,\n      pausedOverlayWrapperStyle = _ref$pausedOverlayWra2 === void 0 ? null : _ref$pausedOverlayWra2,\n      _ref$loadingOverlayWr = _ref.loadingOverlayWrapperClassName,\n      loadingOverlayWrapperClassName = _ref$loadingOverlayWr === void 0 ? '' : _ref$loadingOverlayWr,\n      _ref$loadingOverlayWr2 = _ref.loadingOverlayWrapperStyle,\n      loadingOverlayWrapperStyle = _ref$loadingOverlayWr2 === void 0 ? null : _ref$loadingOverlayWr2,\n      _ref$videoClassName = _ref.videoClassName,\n      videoClassName = _ref$videoClassName === void 0 ? '' : _ref$videoClassName,\n      _ref$videoStyle = _ref.videoStyle,\n      videoStyle = _ref$videoStyle === void 0 ? null : _ref$videoStyle,\n      _ref$sizingMode = _ref.sizingMode,\n      sizingMode = _ref$sizingMode === void 0 ? SIZING_MODES.video : _ref$sizingMode;\n\n  // Keep track of state to determine how the paused and loading overlays should be displayed\n  var _React$useState = React.useState(HOVER_PLAYER_STATE.paused),\n      overlayState = _React$useState[0],\n      setOverlayState = _React$useState[1]; // Keep track of whether the video is unloaded, meaning its sources should be removed from\n  // the DOM and unloaded for optimization purposes\n  // This is only relevant if `unloadVideoOnPaused` is set to true\n\n\n  var _React$useState2 = React.useState(unloadVideoOnPaused),\n      isVideoUnloaded = _React$useState2[0],\n      setIsVideoUnloaded = _React$useState2[1]; // Keep refs to previous state values for comparison in effect hooks\n\n\n  var previousIsVideoUnloadedRef = React.useRef(isVideoUnloaded);\n  var previousFocusedRef = React.useRef(false); // Keep a ref for all state variables related to the video's state\n  // which need to be managed asynchronously as it attempts to play/pause\n\n  var mutableVideoState = React.useRef(null);\n\n  if (mutableVideoState.current === null) {\n    // Set initial values for our video state\n    mutableVideoState.current = {\n      isPlayAttemptInProgress: false,\n      isPlayAttemptCancelled: false,\n      isPlayerUnmounted: false,\n      // Keep refs for timeouts so we can keep track of and cancel them\n      pauseTimeout: null,\n      loadingStateTimeout: null,\n      // Keep track of the video time that we should start from when the video is played again\n      // This is particularly useful so we can restore our previous place in the video even if\n      // we are unloading it every time it gets paused\n      videoTimeToRestore: 0\n    };\n  } // Element refs\n\n\n  var containerRef = React.useRef(null);\n  var videoRef = React.useRef(null);\n  /**\n   * @function  pauseVideo\n   *\n   * Pauses the video and unloads it if necessary\n   */\n\n  var pauseVideo = React.useCallback(function () {\n    var videoElement = videoRef.current;\n    videoElement.pause();\n\n    if (restartOnPaused) {\n      // If we should restart the video, reset its time to the beginning next time we play\n      videoElement.currentTime = 0;\n    } // Hang onto the time that the video is currently at so we can restore it when we try to play\n    // again even if the video was unloaded\n\n\n    mutableVideoState.current.videoTimeToRestore = videoElement.currentTime;\n\n    if (unloadVideoOnPaused) {\n      // If necessary, unload the video now that it's paused\n      setIsVideoUnloaded(true);\n    }\n  }, [restartOnPaused, unloadVideoOnPaused]);\n  /**\n   * @function playVideo\n   *\n   * Attempts to play the video if it is not already playing\n   */\n\n  var playVideo = React.useCallback(function () {\n    // Clear any timeouts that may have been in progress\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    var videoElement = videoRef.current; // Make sure our play attempt is no longer cancelled since the user is hovering on it again\n\n    mutableVideoState.current.isPlayAttemptCancelled = false; // If the video is already playing, just make sure we keep the overlays hidden\n\n    if (getVideoState(videoElement) === VIDEO_STATE.playing) {\n      setOverlayState(HOVER_PLAYER_STATE.playing);\n      return;\n    }\n\n    if (loadingOverlay) {\n      // If we have a loading overlay, start a timeout to fade it in if it takes too long\n      // for playback to start\n      mutableVideoState.current.loadingStateTimeout = setTimeout(function () {\n        // If the video is still loading when this timeout completes, transition the\n        // player to show a loading state\n        setOverlayState(HOVER_PLAYER_STATE.loading);\n      }, loadingStateTimeout);\n    } // If a play attempt is already in progress, don't start a new one\n\n\n    if (mutableVideoState.current.isPlayAttemptInProgress) return; // We are now attempting to play the video\n\n    mutableVideoState.current.isPlayAttemptInProgress = true; // Ensure we're at the correct video time to start playing from\n\n    videoElement.currentTime = mutableVideoState.current.videoTimeToRestore; // Start playing the video and hang onto the play promise it returns\n\n    var playPromise = videoElement.play();\n\n    if (!playPromise || !playPromise.then) {\n      // If videoElement.play() didn't return a promise, we'll manually create one\n      // ourselves which mimics the same behavior\n      playPromise = new Promise(function (resolve, reject) {\n        // Declaring onVideoPlaybackFailed up here so we can refer to it and remove its event listener\n        // if the video successfully starts playing\n        var _onVideoPlaybackFailed; // Set up event listener to resolve the promise when the video player starts playing\n\n\n        var onVideoPlaybackStarted = function onVideoPlaybackStarted() {\n          // Remove the event listeners we added as cleanup now that the play attempt has succeeded\n          videoElement.removeEventListener('playing', onVideoPlaybackStarted);\n          videoElement.removeEventListener('error', _onVideoPlaybackFailed); // Resolve because we successfully started playing!\n\n          resolve();\n        };\n\n        videoElement.addEventListener('playing', onVideoPlaybackStarted); // Set up event listener to reject the promise when the video player encounters an error\n\n        _onVideoPlaybackFailed = function onVideoPlaybackFailed(event) {\n          // Remove the event listeners we added as cleanup now that the play attempt has failed\n          videoElement.removeEventListener('error', _onVideoPlaybackFailed);\n          videoElement.removeEventListener('playing', onVideoPlaybackStarted); // Reject with the error that was thrown\n\n          reject(event.error);\n        };\n\n        videoElement.addEventListener('error', _onVideoPlaybackFailed);\n      });\n    }\n\n    playPromise.then(function () {\n      // If the player was unmounted before the play promise could resolve, don't do anything\n      if (mutableVideoState.current.isPlayerUnmounted) return;\n\n      if (mutableVideoState.current.isPlayAttemptCancelled) {\n        // If the play attempt was cancelled, immediately pause the video\n        pauseVideo();\n      } else {\n        // If the play attempt wasn't cancelled, hide the overlays to reveal the video now that it's playing\n        setOverlayState(HOVER_PLAYER_STATE.playing);\n      }\n    })[\"catch\"](function (error) {\n      console.error(\"HoverVideoPlayer playback failed for src \" + videoElement.currentSrc + \":\", error);\n\n      if (!mutableVideoState.current.isPlayerUnmounted) {\n        // If the player is still mounted, revert to a paused state\n        pauseVideo();\n      }\n    })[\"finally\"](function () {\n      // The play attempt is now complete\n      mutableVideoState.current.isPlayAttemptInProgress = false;\n      mutableVideoState.current.isPlayAttemptCancelled = false;\n      clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    });\n  }, [loadingOverlay, loadingStateTimeout, pauseVideo]);\n  /**\n   * @function  onHoverStart\n   *\n   * Starts the video when the user mouses hovers on the player\n   */\n\n  var onHoverStart = React.useCallback(function () {\n    if (isVideoUnloaded) {\n      // If the video is currently unloaded, we need to make sure we update our state\n      // to restore the video's sources before we attempt to play it\n      setIsVideoUnloaded(false);\n    } else {\n      playVideo();\n    }\n  }, [isVideoUnloaded, playVideo]);\n  /**\n   * @function  onHoverEnd\n   *\n   * Stops the video and fades the paused overlay in when the user stops hovering on the player\n   */\n\n  var onHoverEnd = React.useCallback(function () {\n    // Clear any timeouts that may have been in progress\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    var videoElement = videoRef.current; // If the focused override prop is active, ignore any other events attempting to stop the video\n    // Also don't do anything if the video is already paused\n\n    if (focused || getVideoState(videoElement) === VIDEO_STATE.paused) return; // Start fading the paused overlay back in\n\n    setOverlayState(HOVER_PLAYER_STATE.paused);\n\n    if (mutableVideoState.current.isPlayAttemptInProgress) {\n      // If we have a play attempt in progress, mark that the play attempt should be cancelled\n      // so that as soon as the promise resolves, the video should be paused\n      mutableVideoState.current.isPlayAttemptCancelled = true;\n    } else if (pausedOverlay) {\n      // If we have a paused overlay, set a timeout with a duration of the overlay's fade\n      // transition since we want to keep the video playing until the overlay has fully\n      // faded in and hidden it.\n      mutableVideoState.current.pauseTimeout = setTimeout(function () {\n        return pauseVideo();\n      }, overlayTransitionDuration);\n    } else {\n      // If a play attempt isn't in progress and there is no paused overlay, just pause\n      pauseVideo();\n    }\n  }, [focused, overlayTransitionDuration, pauseVideo, pausedOverlay]);\n  /* ~~~~ EFFECTS ~~~~ */\n\n  React.useEffect(function () {\n    // If the focused prop hasn't changed, don't do anything\n    if (previousFocusedRef.current === focused) return; // Use effect to start/stop the video when focused override prop changes\n\n    if (focused) {\n      onHoverStart();\n    } else {\n      onHoverEnd();\n    }\n\n    previousFocusedRef.current = focused;\n  }, [focused, onHoverEnd, onHoverStart]);\n  React.useEffect(function () {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling) return undefined;\n    var hoverTargetElement = // If a ref to a custom hover target was provided, we'll use that as our target element\n    hoverTargetRef ? hoverTargetRef.current : // If no custom target was provided, default to the player's container div\n    containerRef.current; // Add all relevant event listeners to the target element to make\n    // it start and stop correctly\n\n    hoverTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverTargetElement.addEventListener('mouseleave', onHoverEnd);\n    hoverTargetElement.addEventListener('focus', onHoverStart);\n    hoverTargetElement.addEventListener('blur', onHoverEnd);\n    hoverTargetElement.addEventListener('touchstart', onHoverStart); // Event listener pauses the video when the user touches somewhere outside of the player\n\n    function onWindowTouchStart(event) {\n      if (!hoverTargetElement.contains(event.target)) {\n        onHoverEnd();\n      }\n    }\n\n    window.addEventListener('touchstart', onWindowTouchStart); // Remove all event listeners on cleanup\n\n    return function () {\n      hoverTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverTargetElement.removeEventListener('focus', onHoverStart);\n      hoverTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetRef, onHoverEnd, onHoverStart]);\n  React.useEffect(function () {\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    videoRef.current.muted = muted;\n  }, [muted]);\n  React.useEffect(function () {\n    // Don't do anything if the video's unloaded state hasn't changed\n    if (previousIsVideoUnloadedRef.current === isVideoUnloaded) return; // Since the video's sources have changed, perform a manual load to update\n    // or unload the video's current source\n\n    videoRef.current.load();\n\n    if (!isVideoUnloaded) {\n      // If the video was just changed from being unloaded, that means we're trying to play,\n      // so let's kick off a play attempt now that the video's sources are restored\n      playVideo();\n    }\n\n    previousIsVideoUnloadedRef.current = isVideoUnloaded;\n  }, [isVideoUnloaded, onHoverStart, playVideo]);\n  React.useEffect(function () {\n    var videoElement = videoRef.current; // Ensure casting and PiP controls aren't shown on the video\n\n    videoElement.disableRemotePlayback = true;\n    videoElement.disablePictureInPicture = true;\n    return function () {\n      // Clear any outstanding timeouts when the component unmounts to prevent memory leaks\n      clearTimeout(mutableVideoState.current.pauseTimeout);\n      clearTimeout(mutableVideoState.current.loadingStateTimeout); // Mark that the player is unmounted so that we won't try to update the component state\n      // if the play promise resolves afterward\n\n      mutableVideoState.current.isPlayerUnmounted = true;\n    };\n  }, []);\n  /* ~~~~ END EFFECTS ~~~~ */\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    \"data-testid\": \"hover-video-player-container\",\n    ref: containerRef,\n    className: className,\n    style: _extends({\n      position: 'relative'\n    }, style)\n  }, pausedOverlay && /*#__PURE__*/React.createElement(\"div\", {\n    style: _extends({}, pausedOverlayWrapperSizingStyles[sizingMode], {\n      zIndex: 1,\n      opacity: overlayState !== HOVER_PLAYER_STATE.playing ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\"\n    }, pausedOverlayWrapperStyle),\n    className: pausedOverlayWrapperClassName,\n    \"data-testid\": \"paused-overlay-wrapper\"\n  }, pausedOverlay), loadingOverlay && /*#__PURE__*/React.createElement(\"div\", {\n    style: _extends({}, expandToFillContainerStyle, {\n      zIndex: 2,\n      opacity: overlayState === HOVER_PLAYER_STATE.loading ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\"\n    }, loadingOverlayWrapperStyle),\n    className: loadingOverlayWrapperClassName,\n    \"data-testid\": \"loading-overlay-wrapper\"\n  }, loadingOverlay), /*#__PURE__*/React.createElement(\"video\", {\n    loop: loop,\n    playsInline: true,\n    preload: preload,\n    ref: videoRef,\n    style: _extends({}, videoSizingStyles[sizingMode], {\n      objectFit: 'cover'\n    }, videoStyle),\n    className: videoClassName,\n    \"data-testid\": \"video-element\"\n  }, !isVideoUnloaded && // If the video is not unloaded, parse the `videoSrc` prop into an array of objects and render them\n  // as sources for the video\n  formatVideoSrc(videoSrc).map(function (_ref2) {\n    var src = _ref2.src,\n        type = _ref2.type;\n    return /*#__PURE__*/React.createElement(\"source\", {\n      key: src,\n      src: src,\n      type: type\n    });\n  }), formatVideoCaptions(videoCaptions).map(function (_ref3) {\n    var src = _ref3.src,\n        srcLang = _ref3.srcLang,\n        label = _ref3.label,\n        isDefault = _ref3[\"default\"];\n    return /*#__PURE__*/React.createElement(\"track\", {\n      key: src,\n      kind: \"captions\",\n      src: src,\n      srcLang: srcLang,\n      label: label,\n      \"default\": isDefault\n    });\n  })));\n}"]},"metadata":{},"sourceType":"module"}