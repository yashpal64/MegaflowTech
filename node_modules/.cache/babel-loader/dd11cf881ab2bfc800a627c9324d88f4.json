{"ast":null,"code":"import { VIDEO_STATE } from './constants';\n/**\n * @function getVideoState\n *\n * Takes a video element and returns its current playing state\n *\n * @param {node} videoElement\n */\n\nexport function getVideoState(videoElement) {\n  if (videoElement.paused || videoElement.ended) {\n    return VIDEO_STATE.paused;\n  } // If the video isn't paused but its readyState indicates it isn't loaded enough\n  // to play yet, it is loading\n\n\n  if (videoElement.readyState < 3) {\n    return VIDEO_STATE.loading;\n  } // If the video isn't paused and its ready state indicates it's loaded enough to play,\n  // assume it's playing\n\n\n  return VIDEO_STATE.playing;\n}\n/**\n * @typedef   {object}  VideoSource\n * @property  {string}  src - The src URL string to use for a video player source\n * @property  {string}  type - The media type of the video, ie 'video/mp4'\n */\n\n/**\n * @function  formatVideoSrc\n *\n * Takes a videoSrc value and formats it as an array of VideoSource objects which can be used to render\n * <source> elements for the video\n *\n * @param {(string|string[]|VideoSource|VideoSource[])}  videoSrc - Source(s) to use for the video player. Accepts 3 different formats:\n *                                                                   - **String**: the URL string to use as the video player's src\n *                                                                   - **Object**: an object with attributes:\n *                                                                     - src: The src URL string to use for a video player source\n *                                                                     - type: The media type of the video source, ie 'video/mp4'\n *                                                                   - **Array**: if you would like to provide multiple sources, you can provide an array of URL strings and/or objects with the shape described above\n *\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\n */\n\nexport function formatVideoSrc(videoSrc) {\n  var formattedVideoSources = [];\n\n  if (videoSrc == null) {\n    // A videoSrc value is required in order to make the video player work\n    console.error(\"Error: 'videoSrc' prop is required for HoverVideoPlayer component\");\n  } else {\n    // Make sure we can treat the videoSrc value as an array\n    var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc]; // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n\n    for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {\n      var source = rawVideoSources[i];\n\n      if (typeof source === 'string') {\n        // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n        formattedVideoSources.push({\n          src: source\n        });\n      } else if (source && source.src) {\n        // If the source is an object with an src, just add it to the array\n        formattedVideoSources.push({\n          src: source.src,\n          type: source.type\n        });\n      } else {\n        // Log an error if one of the videoSrc values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\", source);\n      }\n    }\n  }\n\n  return formattedVideoSources;\n}\n/**\n * @typedef   {object}  VideoCaptionsTrack\n * @property  {string}  src - The src URL string for the captions track file\n * @property  {string}  srcLang - The language code for the language that these captions are in\n * @property  {string}  label - The title of the captions track\n * @property  {boolean} default - Whether this track should be used by default if the user's preferences don't match an available srcLang\n */\n\n/**\n * @function formatVideoCaptions\n *\n * Takes a videoCaptions value and formats it as an array of VideoCaptionsTrack objects which can be used to render\n * <track> elements for the video\n *\n * @param {(string|string[]|VideoCaptionsTrack|VideoCaptionsTrack[])} videoCaptions - Captions track(s) to use for the video player for accessibility. Accepts 3 different formats:\n *                                                                                     - **String**: the URL string to use as the captions track's src\n *                                                                                     - **Object**: an object with attributes:\n *                                                                                       - src: The src URL string for the captions track file\n *                                                                                       - srcLang: The language code for the language that these captions are in (ie, 'en', 'es', 'fr')\n *                                                                                       - label: The title of the captions track\n *                                                                                       - default: Whether this track should be used by default if the user's preferences don't match an available srcLang\n *                                                                                     - **Array**: if you would like to provide multiple caption tracks, you can provide an array of objects with the shape described above\n *\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\n */\n\nexport function formatVideoCaptions(videoCaptions) {\n  var formattedVideoCaptions = []; // If captions were provided, format them for use for the video\n\n  if (videoCaptions != null) {\n    // Make sure we can treat the videoCaptions value as an array\n    var rawVideoCaptions = Array.isArray(videoCaptions) ? videoCaptions : [videoCaptions]; // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n    // objects that can be used to render caption tracks for the video\n\n    for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {\n      var captions = rawVideoCaptions[i];\n\n      if (captions && captions.src) {\n        formattedVideoCaptions.push({\n          src: captions.src,\n          srcLang: captions.srcLang,\n          label: captions.label,\n          \"default\": Boolean(captions[\"default\"])\n        });\n      } else {\n        // Log an error if one of the videoCaptions values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\", captions);\n      }\n    }\n  }\n\n  return formattedVideoCaptions;\n}","map":{"version":3,"sources":["C:/Users/Abhinandan Singhal/Desktop/Nayi-Website/node_modules/react-hover-video-player/es/utils.js"],"names":["VIDEO_STATE","getVideoState","videoElement","paused","ended","readyState","loading","playing","formatVideoSrc","videoSrc","formattedVideoSources","console","error","rawVideoSources","Array","isArray","i","numSources","length","source","push","src","type","formatVideoCaptions","videoCaptions","formattedVideoCaptions","rawVideoCaptions","numCaptions","captions","srcLang","label","Boolean"],"mappings":"AAAA,SAASA,WAAT,QAA4B,aAA5B;AACA;;;;;;;;AAQA,OAAO,SAASC,aAAT,CAAuBC,YAAvB,EAAqC;AAC1C,MAAIA,YAAY,CAACC,MAAb,IAAuBD,YAAY,CAACE,KAAxC,EAA+C;AAC7C,WAAOJ,WAAW,CAACG,MAAnB;AACD,GAHyC,CAGxC;AACF;;;AAGA,MAAID,YAAY,CAACG,UAAb,GAA0B,CAA9B,EAAiC;AAC/B,WAAOL,WAAW,CAACM,OAAnB;AACD,GATyC,CASxC;AACF;;;AAGA,SAAON,WAAW,CAACO,OAAnB;AACD;AACD;;;;;;AAMA;;;;;;;;;;;;;;;;AAgBA,OAAO,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;AACvC,MAAIC,qBAAqB,GAAG,EAA5B;;AAEA,MAAID,QAAQ,IAAI,IAAhB,EAAsB;AACpB;AACAE,IAAAA,OAAO,CAACC,KAAR,CAAc,mEAAd;AACD,GAHD,MAGO;AACL;AACA,QAAIC,eAAe,GAAGC,KAAK,CAACC,OAAN,CAAcN,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAA3D,CAFK,CAEkE;;AAEvE,SAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,UAAU,GAAGJ,eAAe,CAACK,MAA7C,EAAqDF,CAAC,GAAGC,UAAzD,EAAqED,CAAC,IAAI,CAA1E,EAA6E;AAC3E,UAAIG,MAAM,GAAGN,eAAe,CAACG,CAAD,CAA5B;;AAEA,UAAI,OAAOG,MAAP,KAAkB,QAAtB,EAAgC;AAC9B;AACAT,QAAAA,qBAAqB,CAACU,IAAtB,CAA2B;AACzBC,UAAAA,GAAG,EAAEF;AADoB,SAA3B;AAGD,OALD,MAKO,IAAIA,MAAM,IAAIA,MAAM,CAACE,GAArB,EAA0B;AAC/B;AACAX,QAAAA,qBAAqB,CAACU,IAAtB,CAA2B;AACzBC,UAAAA,GAAG,EAAEF,MAAM,CAACE,GADa;AAEzBC,UAAAA,IAAI,EAAEH,MAAM,CAACG;AAFY,SAA3B;AAID,OANM,MAMA;AACL;AACAX,QAAAA,OAAO,CAACC,KAAR,CAAc,oEAAd,EAAoFO,MAApF;AACD;AACF;AACF;;AAED,SAAOT,qBAAP;AACD;AACD;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;AAkBA,OAAO,SAASa,mBAAT,CAA6BC,aAA7B,EAA4C;AACjD,MAAIC,sBAAsB,GAAG,EAA7B,CADiD,CAChB;;AAEjC,MAAID,aAAa,IAAI,IAArB,EAA2B;AACzB;AACA,QAAIE,gBAAgB,GAAGZ,KAAK,CAACC,OAAN,CAAcS,aAAd,IAA+BA,aAA/B,GAA+C,CAACA,aAAD,CAAtE,CAFyB,CAE8D;AACvF;;AAEA,SAAK,IAAIR,CAAC,GAAG,CAAR,EAAWW,WAAW,GAAGD,gBAAgB,CAACR,MAA/C,EAAuDF,CAAC,GAAGW,WAA3D,EAAwEX,CAAC,IAAI,CAA7E,EAAgF;AAC9E,UAAIY,QAAQ,GAAGF,gBAAgB,CAACV,CAAD,CAA/B;;AAEA,UAAIY,QAAQ,IAAIA,QAAQ,CAACP,GAAzB,EAA8B;AAC5BI,QAAAA,sBAAsB,CAACL,IAAvB,CAA4B;AAC1BC,UAAAA,GAAG,EAAEO,QAAQ,CAACP,GADY;AAE1BQ,UAAAA,OAAO,EAAED,QAAQ,CAACC,OAFQ;AAG1BC,UAAAA,KAAK,EAAEF,QAAQ,CAACE,KAHU;AAI1B,qBAAWC,OAAO,CAACH,QAAQ,CAAC,SAAD,CAAT;AAJQ,SAA5B;AAMD,OAPD,MAOO;AACL;AACAjB,QAAAA,OAAO,CAACC,KAAR,CAAc,wEAAd,EAAwFgB,QAAxF;AACD;AACF;AACF;;AAED,SAAOH,sBAAP;AACD","sourcesContent":["import { VIDEO_STATE } from './constants';\n/**\n * @function getVideoState\n *\n * Takes a video element and returns its current playing state\n *\n * @param {node} videoElement\n */\n\nexport function getVideoState(videoElement) {\n  if (videoElement.paused || videoElement.ended) {\n    return VIDEO_STATE.paused;\n  } // If the video isn't paused but its readyState indicates it isn't loaded enough\n  // to play yet, it is loading\n\n\n  if (videoElement.readyState < 3) {\n    return VIDEO_STATE.loading;\n  } // If the video isn't paused and its ready state indicates it's loaded enough to play,\n  // assume it's playing\n\n\n  return VIDEO_STATE.playing;\n}\n/**\n * @typedef   {object}  VideoSource\n * @property  {string}  src - The src URL string to use for a video player source\n * @property  {string}  type - The media type of the video, ie 'video/mp4'\n */\n\n/**\n * @function  formatVideoSrc\n *\n * Takes a videoSrc value and formats it as an array of VideoSource objects which can be used to render\n * <source> elements for the video\n *\n * @param {(string|string[]|VideoSource|VideoSource[])}  videoSrc - Source(s) to use for the video player. Accepts 3 different formats:\n *                                                                   - **String**: the URL string to use as the video player's src\n *                                                                   - **Object**: an object with attributes:\n *                                                                     - src: The src URL string to use for a video player source\n *                                                                     - type: The media type of the video source, ie 'video/mp4'\n *                                                                   - **Array**: if you would like to provide multiple sources, you can provide an array of URL strings and/or objects with the shape described above\n *\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\n */\n\nexport function formatVideoSrc(videoSrc) {\n  var formattedVideoSources = [];\n\n  if (videoSrc == null) {\n    // A videoSrc value is required in order to make the video player work\n    console.error(\"Error: 'videoSrc' prop is required for HoverVideoPlayer component\");\n  } else {\n    // Make sure we can treat the videoSrc value as an array\n    var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc]; // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n\n    for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {\n      var source = rawVideoSources[i];\n\n      if (typeof source === 'string') {\n        // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n        formattedVideoSources.push({\n          src: source\n        });\n      } else if (source && source.src) {\n        // If the source is an object with an src, just add it to the array\n        formattedVideoSources.push({\n          src: source.src,\n          type: source.type\n        });\n      } else {\n        // Log an error if one of the videoSrc values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\", source);\n      }\n    }\n  }\n\n  return formattedVideoSources;\n}\n/**\n * @typedef   {object}  VideoCaptionsTrack\n * @property  {string}  src - The src URL string for the captions track file\n * @property  {string}  srcLang - The language code for the language that these captions are in\n * @property  {string}  label - The title of the captions track\n * @property  {boolean} default - Whether this track should be used by default if the user's preferences don't match an available srcLang\n */\n\n/**\n * @function formatVideoCaptions\n *\n * Takes a videoCaptions value and formats it as an array of VideoCaptionsTrack objects which can be used to render\n * <track> elements for the video\n *\n * @param {(string|string[]|VideoCaptionsTrack|VideoCaptionsTrack[])} videoCaptions - Captions track(s) to use for the video player for accessibility. Accepts 3 different formats:\n *                                                                                     - **String**: the URL string to use as the captions track's src\n *                                                                                     - **Object**: an object with attributes:\n *                                                                                       - src: The src URL string for the captions track file\n *                                                                                       - srcLang: The language code for the language that these captions are in (ie, 'en', 'es', 'fr')\n *                                                                                       - label: The title of the captions track\n *                                                                                       - default: Whether this track should be used by default if the user's preferences don't match an available srcLang\n *                                                                                     - **Array**: if you would like to provide multiple caption tracks, you can provide an array of objects with the shape described above\n *\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\n */\n\nexport function formatVideoCaptions(videoCaptions) {\n  var formattedVideoCaptions = []; // If captions were provided, format them for use for the video\n\n  if (videoCaptions != null) {\n    // Make sure we can treat the videoCaptions value as an array\n    var rawVideoCaptions = Array.isArray(videoCaptions) ? videoCaptions : [videoCaptions]; // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n    // objects that can be used to render caption tracks for the video\n\n    for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {\n      var captions = rawVideoCaptions[i];\n\n      if (captions && captions.src) {\n        formattedVideoCaptions.push({\n          src: captions.src,\n          srcLang: captions.srcLang,\n          label: captions.label,\n          \"default\": Boolean(captions[\"default\"])\n        });\n      } else {\n        // Log an error if one of the videoCaptions values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\", captions);\n      }\n    }\n  }\n\n  return formattedVideoCaptions;\n}"]},"metadata":{},"sourceType":"module"}