'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var propTypes = _interopDefault(require('prop-types'));

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".HoverCardHook_Card__1bNJC {\n  overflow: hidden;\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1), 0 4px 8px 0 rgba(0, 0, 0, 0.1);\n  background-color: transparent;\n  width: 100%;\n  overflow: hidden;\n  position: relative;\n  margin: 10px 0;\n  border-radius: 20px;\n  height: 400px;\n}\n\np {\n  margin: 0;\n}\n\n.HoverCardHook_Visible__3yv6X {\n  visibility: visible;\n  opacity: 1;\n  transform: scale(1);\n}\n\n.HoverCardHook_NotVisible__23tQU {\n  display: none;\n  visibility: hidden;\n  opacity: 0;\n  transform: scale(1.5);\n}\n\n.HoverCardHook_Content__1fakz {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  display: flex;\n}\n";
var classes = { "Card": "HoverCardHook_Card__1bNJC", "Visible": "HoverCardHook_Visible__3yv6X", "NotVisible": "HoverCardHook_NotVisible__23tQU", "Content": "HoverCardHook_Content__1fakz" };
styleInject(css);

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var HoverCardHook = function HoverCardHook(props) {
  if (!props.front || !props.back) {
    return null;
  }

  var _useState = React.useState(false),
      _useState2 = slicedToArray(_useState, 2),
      isHover = _useState2[0],
      setHover = _useState2[1];

  var backClass = [classes.Content];
  var frontClass = [classes.Content];

  if (isHover) {
    backClass.push(classes.Visible);
    frontClass.push(classes.NotVisible);
  } else {
    backClass.push(classes.NotVisible);
    frontClass.push(classes.Visible);
  }

  return React__default.createElement(
    'div',
    {
      className: [classes.Card, props.className].join(' '),
      style: _extends({}, props.style, {
        maxWidth: props.maxWidth,
        borderRadius: props.borderRadius,
        height: props.height,
        margin: props.margin
      }),
      onMouseEnter: function onMouseEnter() {
        setHover(true);
      },
      onMouseLeave: function onMouseLeave() {
        setHover(false);
      },
      onFocus: function onFocus() {
        setHover(true);
      },
      onBlur: function onBlur() {
        setHover(false);
      },
      onClick: function onClick() {
        setHover(true);
      },
      onTouchStart: function onTouchStart() {
        setHover(true);
      }
    },
    React__default.createElement(
      'div',
      {
        className: frontClass.join(' '),
        style: { transition: 'all ' + (props.animationSpeed || 250) + 'ms' }
      },
      props.front
    ),
    React__default.createElement(
      'div',
      {
        className: backClass.join(' '),
        style: { transition: 'all ' + (props.animationSpeed || 250) + 'ms' }
      },
      props.back
    )
  );
};

HoverCardHook.propTypes = {
  front: propTypes.any,
  back: propTypes.any,
  style: propTypes.any,
  className: propTypes.any,
  maxWidth: propTypes.number,
  animationSpeed: propTypes.number,
  borderRadius: propTypes.number,
  height: propTypes.number,
  margin: propTypes.number
};

var css$1 = ".HoverCardClass_Card__IrMgs {\n  overflow: hidden;\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1), 0 4px 8px 0 rgba(0, 0, 0, 0.1);\n  background-color: transparent;\n  width: 100%;\n  overflow: hidden;\n  position: relative;\n  margin: 10px 0;\n  border-radius: 20px;\n  height: 400px;\n}\n\np {\n  margin: 0;\n}\n\n.HoverCardClass_Visible__srLqj {\n  visibility: visible;\n  opacity: 1;\n  transform: scale(1);\n}\n\n.HoverCardClass_NotVisible__2pmg6 {\n  display: none;\n  visibility: hidden;\n  opacity: 0;\n  transform: scale(1.5);\n}\n\n.HoverCardClass_Content__3pale {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  display: flex;\n}\n";
var classes$1 = { "Card": "HoverCardClass_Card__IrMgs", "Visible": "HoverCardClass_Visible__srLqj", "NotVisible": "HoverCardClass_NotVisible__2pmg6", "Content": "HoverCardClass_Content__3pale" };
styleInject(css$1);

var HoverCardClass = function (_Component) {
  inherits(HoverCardClass, _Component);

  function HoverCardClass() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, HoverCardClass);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = HoverCardClass.__proto__ || Object.getPrototypeOf(HoverCardClass)).call.apply(_ref, [this].concat(args))), _this), _this.state = { isHover: false }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(HoverCardClass, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      if (!this.props.front || !this.props.back) {
        return null;
      }

      var backClass = [classes$1.Content];
      var frontClass = [classes$1.Content];

      if (this.state.isHover) {
        backClass.push(classes$1.Visible);
        frontClass.push(classes$1.NotVisible);
      } else {
        backClass.push(classes$1.NotVisible);
        frontClass.push(classes$1.Visible);
      }

      return React__default.createElement(
        'div',
        {
          className: [classes$1.Card, this.props.className].join(' '),
          style: _extends({}, this.props.style, {
            maxWidth: this.props.maxWidth,
            borderRadius: this.props.borderRadius,
            height: this.props.height,
            margin: this.props.margin
          }),
          onMouseEnter: function onMouseEnter() {
            _this2.setState({ isHover: true });
          },
          onMouseLeave: function onMouseLeave() {
            _this2.setState({ isHover: false });
          },
          onFocus: function onFocus() {
            _this2.setState({ isHover: true });
          },
          onBlur: function onBlur() {
            _this2.setState({ isHover: false });
          }
        },
        React__default.createElement(
          'div',
          {
            className: frontClass.join(' '),
            style: { transition: 'all ' + (this.props.animationSpeed || 250) + 'ms' }
          },
          this.props.front
        ),
        React__default.createElement(
          'div',
          {
            className: backClass.join(' '),
            style: { transition: 'all ' + (this.props.animationSpeed || 250) + 'ms' }
          },
          this.props.back
        )
      );
    }
  }]);
  return HoverCardClass;
}(React.Component);

HoverCardClass.propTypes = {
  front: propTypes.any,
  back: propTypes.any,
  style: propTypes.any,
  className: propTypes.any,
  maxWidth: propTypes.number,
  animationSpeed: propTypes.number,
  borderRadius: propTypes.number,
  height: propTypes.number,
  margin: propTypes.number
};

var HoverCard = HoverCardClass;

exports.HoverCard = HoverCard;
exports.default = HoverCardHook;
//# sourceMappingURL=index.js.map
